<!DOCTYPE html>
<html>
<head>
    <title>FPV Simulator</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="hud"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, drone;
        let controls = {
            throttle: 0,
            pitch: 0,
            roll: 0,
            yaw: 0
        };
        
        // Physics constants
        const GRAVITY = 9.8;
        const DRONE_MASS = 0.5;
        const MAX_THRUST = 25.0;
        const DRAG_COEFFICIENT = 0.02;
        const ANGULAR_DRAG = 0.85;
        const PITCH_RATE = 4.0;
        const ROLL_RATE = 4.0;
        const YAW_RATE = 3.0;
        const MAP_BOUNDARY = 100; // Maximum distance from center
        
        // State variables
        let velocity = new THREE.Vector3();
        let angularVelocity = new THREE.Vector3();
        let clock = new THREE.Clock();
        let collisionObjects = [];
        let lastCollisionTime = 0;
        let batteryLevel = 100;
        let isFlying = false;
        let isPaused = false;
        let hudVisible = true;
        let cameraMode = 'fpv'; // Add camera mode tracking: 'fpv', 'chase', 'external'
        
        // Camera settings
        const CAMERA_FOV = 90;
        const CAMERA_TILT = -15; // Degrees

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.01); // Add fog for distance
            
            camera = new THREE.PerspectiveCamera(CAMERA_FOV, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 200, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            // Drone
            createDrone();
            
            // Position camera with tilt
            camera.position.set(0, 0.05, -0.2);
            camera.rotation.x = THREE.MathUtils.degToRad(CAMERA_TILT);
            drone.add(camera);

            // Environment
            createEnvironment();

            // Event listeners
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);
            
            // Start with instructions
            showInstructions();
        }

        function createDrone() {
            drone = new THREE.Group();
            
            // Drone body
            const bodyGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.2);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0x222222,
                specular: 0x111111,
                shininess: 100
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            drone.add(body);

            // Add frame
            const frameGeometry = new THREE.BoxGeometry(0.25, 0.02, 0.25);
            const frameMaterial = new THREE.MeshPhongMaterial({
                color: 0xE53935, // Red frame
                specular: 0x222222,
                shininess: 30
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.y = -0.02;
            frame.castShadow = true;
            drone.add(frame);

            // Add arms and rotors
            const armGeometry = new THREE.BoxGeometry(0.04, 0.02, 0.3);
            const armMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
            
            const rotorGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.01, 16);
            const rotorMaterial = new THREE.MeshPhongMaterial({color: 0x888888});
            const rotorHubGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.02, 8);
            const rotorHubMaterial = new THREE.MeshPhongMaterial({color: 0xFFFFFF});
            
            // Create 4 arms with rotors
            const armPositions = [
                {x: 0, z: 0.15, angle: 0},
                {x: 0.15, z: 0, angle: Math.PI/2},
                {x: 0, z: -0.15, angle: Math.PI},
                {x: -0.15, z: 0, angle: -Math.PI/2}
            ];
            
            armPositions.forEach((pos, i) => {
                // Arm
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.position.set(pos.x/2, 0, pos.z/2);
                arm.rotation.y = pos.angle;
                arm.castShadow = true;
                drone.add(arm);
                
                // Rotor hub
                const hub = new THREE.Mesh(rotorHubGeometry, rotorHubMaterial);
                hub.position.set(pos.x, 0.02, pos.z);
                hub.castShadow = true;
                drone.add(hub);
                
                // Rotor
                const rotor = new THREE.Mesh(rotorGeometry, rotorMaterial);
                rotor.position.set(pos.x, 0.035, pos.z);
                rotor.castShadow = true;
                rotor.userData = { isRotor: true, index: i };
                drone.add(rotor);
            });
            
            // Add LED lights
            const ledGeometry = new THREE.SphereGeometry(0.01, 8, 8);
            const frontLedMaterial = new THREE.MeshBasicMaterial({color: 0x00FF00}); // Green front
            const backLedMaterial = new THREE.MeshBasicMaterial({color: 0xFF0000}); // Red back
            
            const frontLed = new THREE.Mesh(ledGeometry, frontLedMaterial);
            frontLed.position.set(0, 0, 0.12);
            drone.add(frontLed);
            
            const backLed = new THREE.Mesh(ledGeometry, backLedMaterial);
            backLed.position.set(0, 0, -0.12);
            drone.add(backLed);
            
            // Add camera mount
            const cameraMountGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
            const cameraMountMaterial = new THREE.MeshPhongMaterial({color: 0x222222});
            const cameraMount = new THREE.Mesh(cameraMountGeometry, cameraMountMaterial);
            cameraMount.position.set(0, 0, 0.1);
            drone.add(cameraMount);
            
            drone.position.set(0, 1.5, 0);
            scene.add(drone);
            
            // Add drone to collision objects
            drone.userData = { isDrone: true };
            collisionObjects.push(drone);
        }

        function createEnvironment() {
            // Ground
            const groundSize = 200;
            const groundTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(25, 25);
            groundTexture.anisotropy = 16;
            
            const groundMaterial = new THREE.MeshPhongMaterial({
                map: groundTexture,
                side: THREE.DoubleSide
            });
            
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add race gates
            createRaceGates();
            
            // Add trees and obstacles
            addObstacles();
            
            // Add buildings
            addBuildings();
        }

        function createRaceGates() {
            const gatePositions = [
                {x: 10, y: 2, z: 10, rotation: Math.PI/4},
                {x: 20, y: 3, z: 15, rotation: -Math.PI/6},
                {x: 15, y: 4, z: 25, rotation: Math.PI/2},
                {x: 0, y: 2, z: 30, rotation: 0},
                {x: -15, y: 3, z: 20, rotation: -Math.PI/3},
                {x: -20, y: 5, z: 0, rotation: Math.PI/4},
                {x: -10, y: 2, z: -15, rotation: -Math.PI/8},
                {x: 5, y: 3, z: -20, rotation: Math.PI/6}
            ];
            
            const gateGeometry = new THREE.TorusGeometry(2, 0.1, 16, 32);
            const gateMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFF00,
                emissive: 0x444400
            });
            
            gatePositions.forEach((pos, index) => {
                const gate = new THREE.Mesh(gateGeometry, gateMaterial);
                gate.position.set(pos.x, pos.y, pos.z);
                gate.rotation.y = pos.rotation;
                gate.rotation.x = Math.PI/2;
                gate.castShadow = true;
                scene.add(gate);
                
                // Add a simple marker instead of text
                const markerGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const markerMaterial = new THREE.MeshBasicMaterial({color: 0xFFFFFF});
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(pos.x, pos.y + 2.5, pos.z);
                scene.add(marker);
                
                // Add to collision objects
                gate.userData = { isGate: true, gateNumber: index + 1 };
                collisionObjects.push(gate);
            });
        }

        function addObstacles() {
            // Trees
            const treeCount = 30;
            const treePositions = [];
            
            // Generate random positions away from gates
            for (let i = 0; i < treeCount; i++) {
                const x = Math.random() * 100 - 50;
                const z = Math.random() * 100 - 50;
                
                // Check if too close to gates or other trees
                let tooClose = false;
                
                // Add tree if not too close
                if (!tooClose) {
                    treePositions.push({x, z});
                    createTree(x, z);
                }
            }
            
            // Add some rocks
            for (let i = 0; i < 20; i++) {
                createRock(
                    Math.random() * 100 - 50,
                    Math.random() * 100 - 50
                );
            }
        }

        function createTree(x, z) {
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.4, 3, 8);
            const trunkMaterial = new THREE.MeshPhongMaterial({color: 0x8B4513});
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, 1.5, z);
            trunk.castShadow = true;
            scene.add(trunk);
            
            const foliageGeometry = new THREE.ConeGeometry(2, 4, 8);
            const foliageMaterial = new THREE.MeshPhongMaterial({color: 0x228B22});
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.set(x, 5, z);
            foliage.castShadow = true;
            scene.add(foliage);
            
            // Add to collision objects
            trunk.userData = { isObstacle: true };
            foliage.userData = { isObstacle: true };
            collisionObjects.push(trunk);
            collisionObjects.push(foliage);
        }

        function createRock(x, z) {
            const size = Math.random() * 1 + 0.5;
            const rockGeometry = new THREE.DodecahedronGeometry(size, 0);
            const rockMaterial = new THREE.MeshPhongMaterial({
                color: 0x888888,
                flatShading: true
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(x, size/2, z);
            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rock.castShadow = true;
            rock.receiveShadow = true;
            scene.add(rock);
            
            // Add to collision objects
            rock.userData = { isObstacle: true };
            collisionObjects.push(rock);
        }

        function addBuildings() {
            const buildingCount = 10;
            
            for (let i = 0; i < buildingCount; i++) {
                const x = Math.random() * 150 - 75;
                const z = Math.random() * 150 - 75;
                
                // Don't place buildings in the center area
                if (Math.abs(x) < 30 && Math.abs(z) < 30) continue;
                
                createBuilding(x, z);
            }
        }

        function createBuilding(x, z) {
            const width = Math.random() * 10 + 5;
            const height = Math.random() * 20 + 10;
            const depth = Math.random() * 10 + 5;
            
            // Create a more interesting building shape
            const buildingGroup = new THREE.Group();
            buildingGroup.position.set(x, height/2, z);
            scene.add(buildingGroup);
            
            // Main building body
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const buildingMaterial = new THREE.MeshPhongMaterial({
                color: 0xAAAAAA,
                flatShading: true,
                shininess: 30
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.castShadow = true;
            building.receiveShadow = true;
            buildingGroup.add(building);
            
            // Add a roof structure
            const roofHeight = Math.random() * 2 + 1;
            const roofGeometry = new THREE.BoxGeometry(width * 0.7, roofHeight, depth * 0.7);
            const roofMaterial = new THREE.MeshPhongMaterial({
                color: 0x777777,
                flatShading: true
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = height/2 + roofHeight/2;
            roof.castShadow = true;
            buildingGroup.add(roof);
            
            // Add windows with actual geometry instead of planes
            const windowSize = 0.8;
            const windowDepth = 0.1;
            const windowGeometry = new THREE.BoxGeometry(windowSize, windowSize, windowDepth);
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFF99,
                emissive: 0x555500,
                transparent: true,
                opacity: 0.9,
                shininess: 100
            });
            
            // Calculate window rows and columns
            const windowRows = Math.floor(height / 2) - 1;
            const windowColsX = Math.floor(width / 1.5);
            const windowColsZ = Math.floor(depth / 1.5);
            
            // Add windows to each side
            // Front side
            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowColsX; col++) {
                    if (Math.random() > 0.3) { // Some randomness in window placement
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        windowMesh.position.set(
                            (col - windowColsX/2 + 0.5) * 1.5,
                            (row - windowRows/2 + 0.5) * 2,
                            depth/2 + windowDepth/2
                        );
                        buildingGroup.add(windowMesh);
                    }
                }
            }
            
            // Back side
            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowColsX; col++) {
                    if (Math.random() > 0.3) {
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        windowMesh.position.set(
                            (col - windowColsX/2 + 0.5) * 1.5,
                            (row - windowRows/2 + 0.5) * 2,
                            -depth/2 - windowDepth/2
                        );
                        buildingGroup.add(windowMesh);
                    }
                }
            }
            
            // Left side
            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowColsZ; col++) {
                    if (Math.random() > 0.3) {
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        windowMesh.position.set(
                            -width/2 - windowDepth/2,
                            (row - windowRows/2 + 0.5) * 2,
                            (col - windowColsZ/2 + 0.5) * 1.5
                        );
                        windowMesh.rotation.y = Math.PI/2;
                        buildingGroup.add(windowMesh);
                    }
                }
            }
            
            // Right side
            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowColsZ; col++) {
                    if (Math.random() > 0.3) {
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        windowMesh.position.set(
                            width/2 + windowDepth/2,
                            (row - windowRows/2 + 0.5) * 2,
                            (col - windowColsZ/2 + 0.5) * 1.5
                        );
                        windowMesh.rotation.y = Math.PI/2;
                        buildingGroup.add(windowMesh);
                    }
                }
            }
            
            // Add some architectural details
            if (Math.random() > 0.5) {
                // Add columns at corners
                const columnRadius = 0.4;
                const columnGeometry = new THREE.CylinderGeometry(columnRadius, columnRadius, height, 8);
                const columnMaterial = new THREE.MeshPhongMaterial({color: 0x999999});
                
                // Place columns at corners
                const cornerPositions = [
                    {x: width/2 - columnRadius/2, z: depth/2 - columnRadius/2},
                    {x: -width/2 + columnRadius/2, z: depth/2 - columnRadius/2},
                    {x: width/2 - columnRadius/2, z: -depth/2 + columnRadius/2},
                    {x: -width/2 + columnRadius/2, z: -depth/2 + columnRadius/2}
                ];
                
                cornerPositions.forEach(pos => {
                    const column = new THREE.Mesh(columnGeometry, columnMaterial);
                    column.position.set(pos.x, 0, pos.z);
                    column.castShadow = true;
                    buildingGroup.add(column);
                });
            }
            
            // Add to collision objects
            building.userData = { isObstacle: true };
            collisionObjects.push(building);
            
            return buildingGroup;
        }

        function updatePhysics(deltaTime) {
            // Cap deltaTime to prevent large jumps
            deltaTime = Math.min(deltaTime, 0.05);
            
            // Animate rotors
            drone.children.forEach(child => {
                if (child.userData && child.userData.isRotor) {
                    child.rotation.y += (controls.throttle * 2 + 0.5) * deltaTime * 30;
                }
            });
            
            // Apply controls
            const thrust = controls.throttle * MAX_THRUST;
            
            // Apply angular forces based on controls
            angularVelocity.x += controls.pitch * PITCH_RATE * deltaTime;
            angularVelocity.z += controls.roll * ROLL_RATE * deltaTime;
            angularVelocity.y += controls.yaw * YAW_RATE * deltaTime;
            
            // Apply angular velocity
            drone.rotation.x += angularVelocity.x * deltaTime;
            drone.rotation.y += angularVelocity.y * deltaTime;
            drone.rotation.z += angularVelocity.z * deltaTime;
            
            // Convert local rotation to global forces
            const quaternion = drone.quaternion.clone();
            const thrustVector = new THREE.Vector3(0, thrust, 0);
            thrustVector.applyQuaternion(quaternion);
            
            // Apply forces
            velocity.add(thrustVector.multiplyScalar(deltaTime / DRONE_MASS));
            velocity.y -= GRAVITY * deltaTime;
            
            // Apply drag (air resistance)
            const dragForce = velocity.clone().multiplyScalar(-DRAG_COEFFICIENT * velocity.length());
            velocity.add(dragForce.multiplyScalar(deltaTime));
            
            // Apply angular drag
            angularVelocity.multiplyScalar(ANGULAR_DRAG);
            
            // Apply movement
            const prevPosition = drone.position.clone();
            drone.position.add(velocity.clone().multiplyScalar(deltaTime));
            
            // Enforce map boundaries
            const distanceFromCenter = Math.sqrt(drone.position.x * drone.position.x + drone.position.z * drone.position.z);
            if (distanceFromCenter > MAP_BOUNDARY) {
                // Calculate direction vector from center to drone
                const directionFromCenter = new THREE.Vector3(drone.position.x, 0, drone.position.z).normalize();
                
                // Set position at boundary
                drone.position.x = directionFromCenter.x * MAP_BOUNDARY;
                drone.position.z = directionFromCenter.z * MAP_BOUNDARY;
                
                // Bounce back slightly
                velocity.x *= -0.5;
                velocity.z *= -0.5;
                
                // Visual feedback
                if (velocity.length() > 3) {
                    handleCrash();
                }
            }
            
            // Enforce height limit
            const MAX_HEIGHT = 50;
            if (drone.position.y > MAX_HEIGHT) {
                drone.position.y = MAX_HEIGHT;
                velocity.y = 0;
            }
            
            // Check collisions
            checkCollisions(prevPosition);
            
            // Ground collision
            if (drone.position.y < 0.1) {
                drone.position.y = 0.1;
                velocity.y = Math.max(0, velocity.y);
                
                // If hitting ground at high speed, crash
                if (velocity.length() > 5) {
                    handleCrash();
                }
            }
            
            // Update battery
            if (isFlying) {
                batteryLevel -= deltaTime * (0.5 + controls.throttle * 1.5);
                if (batteryLevel <= 0) {
                    batteryLevel = 0;
                    controls.throttle = 0;
                }
            }
        }

        function checkCollisions(prevPosition) {
            // Raycasting for precise collision detection
            const direction = new THREE.Vector3();
            direction.subVectors(drone.position, prevPosition).normalize();
            
            const raycaster = new THREE.Raycaster(prevPosition, direction);
            const intersects = raycaster.intersectObjects(collisionObjects);
            
            // Check if we hit something
            if (intersects.length > 0) {
                const hit = intersects[0];
                
                // Don't collide with self
                if (hit.object.userData && hit.object.userData.isDrone) {
                    return;
                }
                
                // Check if we hit a gate
                if (hit.object.userData && hit.object.userData.isGate) {
                    // Handle gate passing
                    console.log("Passed gate " + hit.object.userData.gateNumber);
                    return;
                }
                
                // If we hit an obstacle
                if (hit.distance < direction.length() * prevPosition.distanceTo(drone.position)) {
                    // Collision response
                    if (velocity.length() > 3) {
                        handleCrash();
                    } else {
                        // Bounce off
                        drone.position.copy(prevPosition);
                        velocity.multiplyScalar(-0.5);
                    }
                }
            }
        }

        function handleCrash() {
            if (Date.now() - lastCollisionTime < 1000) return; // Prevent multiple crashes
            
            console.log("Crash!");
            lastCollisionTime = Date.now();
            
            // Visual feedback
            velocity.multiplyScalar(0.2);
            
            // Damage battery
            batteryLevel = Math.max(0, batteryLevel - 20);
        }

        function onKeyDown(event) {
            switch(event.key.toLowerCase()) {
                case ' ':
                    controls.throttle = Math.min(controls.throttle + 0.1, 1.0);
                    isFlying = true;
                    break;
                case 'shift':
                    controls.throttle = Math.max(controls.throttle - 0.1, 0);
                    break;
                case 'w':
                    controls.pitch = -1.0;
                    break;
                case 's':
                    controls.pitch = 1.0;
                    break;
                case 'a':
                    controls.roll = 1.0;
                    break;
                case 'd':
                    controls.roll = -1.0;
                    break;
                case 'q':
                    controls.yaw = 1.0;
                    break;
                case 'e':
                    controls.yaw = -1.0;
                    break;
                case 'r':
                    resetDrone();
                    break;
                case 'c':
                    toggleCameraView();
                    break;
                case 'b':
                    batteryLevel = 100; // Battery recharge cheat
                    break;
                case 'p':
                    togglePause();
                    break;
                case 'h':
                    toggleHUD();
                    break;
            }
        }

        function onKeyUp(event) {
            switch(event.key.toLowerCase()) {
                case ' ':
                case 'shift':
                    // Don't reset throttle on key up
                    break;
                case 'w':
                case 's':
                    controls.pitch = 0;
                    break;
                case 'a':
                case 'd':
                    controls.roll = 0;
                    break;
                case 'q':
                case 'e':
                    controls.yaw = 0;
                    break;
            }
        }

        function resetDrone() {
            drone.position.set(0, 1.5, 0);
            velocity.set(0, 0, 0);
            angularVelocity.set(0, 0, 0);
            drone.rotation.set(0, 0, 0);
            controls.throttle = 0;
            controls.pitch = 0;
            controls.roll = 0;
            controls.yaw = 0;
            batteryLevel = 100;
            isFlying = false;
        }

        function toggleCameraView() {
            // Cycle through camera views: FPV -> Chase -> External -> FPV
            switch(cameraMode) {
                case 'fpv':
                    // Switch to chase view (behind drone)
                    cameraMode = 'chase';
                    drone.remove(camera);
                    scene.add(camera);
                    camera.position.set(0, 0, 0);
                    camera.rotation.set(0, 0, 0);
                    break;
                    
                case 'chase':
                    // Switch to external view (see the drone from outside)
                    cameraMode = 'external';
                    camera.position.set(5, 5, 5);
                    camera.lookAt(drone.position);
                    break;
                    
                case 'external':
                    // Switch back to FPV
                    cameraMode = 'fpv';
                    scene.remove(camera);
                    drone.add(camera);
                    camera.position.set(0, 0.05, -0.2);
                    camera.rotation.x = THREE.MathUtils.degToRad(CAMERA_TILT);
                    break;
            }
            
            // Update HUD to show current camera mode
            updateHUD();
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                showPauseScreen();
            } else {
                hidePauseScreen();
            }
        }

        function toggleHUD() {
            hudVisible = !hudVisible;
            document.getElementById('hud').style.display = hudVisible ? 'block' : 'none';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateHUD() {
            if (!hudVisible) return;
            
            const hud = document.getElementById('hud');
            const speed = velocity.length().toFixed(1);
            const altitude = drone.position.y.toFixed(1);
            const batteryPercentage = batteryLevel.toFixed(0);
            
            // Camera mode display
            let cameraModeText = '';
            switch(cameraMode) {
                case 'fpv':
                    cameraModeText = 'First Person View';
                    break;
                case 'chase':
                    cameraModeText = 'Chase View';
                    break;
                case 'external':
                    cameraModeText = 'External View';
                    break;
            }
            
            // Calculate distance from center for boundary warning
            const distanceFromCenter = Math.sqrt(drone.position.x * drone.position.x + drone.position.z * drone.position.z);
            const boundaryWarning = distanceFromCenter > MAP_BOUNDARY * 0.8 ? 
                `<div style="color: #FF0000; font-weight: bold;">BOUNDARY WARNING: ${(MAP_BOUNDARY - distanceFromCenter).toFixed(1)}m</div>` : '';
            
            // Battery color based on level
            let batteryColor = '#00FF00'; // Green
            if (batteryLevel < 30) batteryColor = '#FF0000'; // Red
            else if (batteryLevel < 70) batteryColor = '#FFFF00'; // Yellow
            
            // Create artificial horizon
            const horizonHTML = createArtificialHorizon();
            
            hud.innerHTML = `
                <div style="background-color: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; width: 300px;">
                    <div style="font-size: 18px; margin-bottom: 5px; text-align: center;">FPV DRONE SIMULATOR</div>
                    <div style="display: flex; justify-content: space-between;">
                        <div>
                            <div>Speed: <span style="color: ${speed > 10 ? '#FF0000' : '#FFFFFF'}">${speed} m/s</span></div>
                            <div>Altitude: ${altitude} m</div>
                            <div>Camera: ${cameraModeText}</div>
                            <div>Battery: <span style="color: ${batteryColor}">${batteryPercentage}%</span>
                                <div style="width: 100px; height: 10px; background-color: #333; margin-top: 2px; border-radius: 5px;">
                                    <div style="width: ${batteryPercentage}px; height: 10px; background-color: ${batteryColor}; border-radius: 5px;"></div>
                                </div>
                            </div>
                            ${boundaryWarning}
                        </div>
                        <div style="margin-left: 20px;">
                            ${createArtificialHorizon()}
                        </div>
                    </div>
                    <div style="margin-top: 10px; font-size: 12px;">
                        <div>SPACE/SHIFT - Throttle Up/Down</div>
                        <div>W/S - Pitch | A/D - Roll | Q/E - Yaw</div>
                        <div>R - Reset | C - Camera | H - Hide HUD | P - Pause</div>
                    </div>
                </div>
            `;
        }

        function createArtificialHorizon() {
            const width = 100;
            const height = 100;
            const pitch = THREE.MathUtils.radToDeg(drone.rotation.x);
            const roll = THREE.MathUtils.radToDeg(drone.rotation.z);
            
            // Limit pitch display to +/- 90 degrees
            const pitchOffset = Math.max(Math.min(pitch, 90), -90) * height / 180;
            
            return `
                <div style="width: ${width}px; height: ${height}px; border: 2px solid #FFFFFF; border-radius: 50%; position: relative; overflow: hidden; background-color: #333333;">
                    <div style="position: absolute; width: 140%; height: 50%; background-color: #87CEEB; top: 0; left: -20%; transform: rotate(${-roll}deg) translateY(${pitchOffset}px);"></div>
                    <div style="position: absolute; width: 140%; height: 50%; background-color: #8B4513; bottom: 0; left: -20%; transform: rotate(${-roll}deg) translateY(${pitchOffset}px);"></div>
                    <div style="position: absolute; width: 100%; height: 2px; background-color: white; top: 50%; left: 0;"></div>
                    <div style="position: absolute; width: 2px; height: 100%; background-color: white; left: 50%; top: 0;"></div>
                    
                    <!-- Roll indicator -->
                    <div style="position: absolute; width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 10px solid red; top: 5px; left: calc(50% - 10px); transform: rotate(${-roll}deg);"></div>
                    
                    <!-- Pitch markers -->
                    <div style="position: absolute; width: 20px; height: 2px; background-color: white; top: calc(50% - 25px); left: calc(50% - 10px); transform: rotate(${-roll}deg) translateY(${pitchOffset}px);"></div>
                    <div style="position: absolute; width: 20px; height: 2px; background-color: white; top: calc(50% + 25px); left: calc(50% - 10px); transform: rotate(${-roll}deg) translateY(${pitchOffset}px);"></div>
                </div>
            `;
        }

        function showInstructions() {
            // Create instructions overlay
            const instructionsDiv = document.createElement('div');
            instructionsDiv.id = 'instructions';
            instructionsDiv.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.8);
                color: white;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                font-family: Arial, sans-serif;
                z-index: 100;
            `;
            
            instructionsDiv.innerHTML = `
                <h1>FPV Drone Simulator</h1>
                <div style="max-width: 600px; text-align: center; margin-bottom: 30px;">
                    <p>Experience the thrill of FPV drone racing in this realistic simulator.</p>
                    <p>Navigate through race gates, avoid obstacles, and manage your battery life.</p>
                </div>
                <div style="display: grid; grid-template-columns: auto auto; gap: 20px; margin-bottom: 30px;">
                    <div>
                        <h3>Flight Controls:</h3>
                        <p>SPACE - Increase Throttle</p>
                        <p>SHIFT - Decrease Throttle</p>
                        <p>W/S - Pitch Forward/Back</p>
                        <p>A/D - Roll Left/Right</p>
                        <p>Q/E - Yaw Left/Right</p>
                    </div>
                    <div>
                        <h3>Other Controls:</h3>
                        <p>R - Reset Drone Position</p>
                        <p>C - Toggle Camera View (FPV/Chase/External)</p>
                        <p>H - Toggle HUD Display</p>
                        <p>P - Pause Game</p>
                        <p>B - Emergency Battery Recharge</p>
                    </div>
                </div>
                <button id="startButton" style="padding: 10px 20px; font-size: 18px; cursor: pointer;">START FLYING</button>
            `;
            
            document.body.appendChild(instructionsDiv);
            
            // Add event listener to start button
            document.getElementById('startButton').addEventListener('click', () => {
                document.body.removeChild(instructionsDiv);
                // Start the clock when the user begins
                clock.start();
            });
        }

        function showPauseScreen() {
            // Create pause overlay
            const pauseDiv = document.createElement('div');
            pauseDiv.id = 'pauseScreen';
            pauseDiv.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.6);
                color: white;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                font-family: Arial, sans-serif;
                z-index: 100;
            `;
            
            pauseDiv.innerHTML = `
                <h1>PAUSED</h1>
                <p>Press P to resume</p>
                <button id="resumeButton" style="padding: 10px 20px; margin-top: 20px; cursor: pointer;">RESUME</button>
                <button id="restartButton" style="padding: 10px 20px; margin-top: 10px; cursor: pointer;">RESTART</button>
            `;
            
            document.body.appendChild(pauseDiv);
            
            // Add event listeners
            document.getElementById('resumeButton').addEventListener('click', togglePause);
            document.getElementById('restartButton').addEventListener('click', () => {
                togglePause();
                resetDrone();
            });
        }

        function hidePauseScreen() {
            const pauseScreen = document.getElementById('pauseScreen');
            if (pauseScreen) {
                document.body.removeChild(pauseScreen);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (isPaused) return;
            
            const deltaTime = Math.min(0.033, clock.getDelta()); // Cap deltaTime
            
            updatePhysics(deltaTime);
            updateHUD();
            
            // Update camera position for chase and external views
            if (cameraMode === 'chase') {
                // Position camera behind drone
                const droneDirection = new THREE.Vector3(0, 0, 1).applyQuaternion(drone.quaternion);
                const cameraPosition = drone.position.clone().sub(droneDirection.multiplyScalar(3));
                cameraPosition.y += 1; // Slightly above drone
                
                camera.position.copy(cameraPosition);
                camera.lookAt(drone.position);
            } else if (cameraMode === 'external') {
                // External view - camera orbits around drone
                camera.position.x = drone.position.x + 5 * Math.sin(Date.now() * 0.0005);
                camera.position.z = drone.position.z + 5 * Math.cos(Date.now() * 0.0005);
                camera.position.y = drone.position.y + 3;
                camera.lookAt(drone.position);
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
